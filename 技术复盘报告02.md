### **技术复盘报告：从零构建并通过`nestest`验证的6502 CPU核心**

**版本:** 1.0
**项目:** MyNES-C
**作者:** 您的专属AI教授
**日期:** 2025年7月3日

#### **1. 需求起源与核心目标 (The "Why")**

我们的旅程始于一个宏大的目标：**从第一性原理出发，理解计算机是如何工作的**。我们选择构建一个NES模拟器作为实践载体，因为它足够简单，能让我们在不被现代计算机过分复杂的细节淹没的情况下，亲手触摸到计算的本质；同时它又足够完整，涵盖了CPU、内存、图形、输入等所有核心要素。

**核心需求被分解为：**
1.  **构建一个虚拟的CPU**：它必须能理解并执行一种被称为“机器语言”的底层指令。
2.  **构建一个虚拟的内存系统**：它能存储程序和数据，并响应CPU的读写请求。
3.  **将两者连接起来**：通过一个“总线”系统，让CPU能访问内存。
4.  **验证其正确性**：使用业界公认的测试标准（`nestest.nes`）来证明我们的虚拟CPU与真实的硬件行为完全一致。

#### **2. 问题的来龙去脉与演进 (The Journey & The Hurdles)**

我们的开发过程并非一帆风顺，而是经历了一系列精心设计的、从简单到复杂的阶段。每一个阶段都暴露了新的问题，解决这些问题的过程，就是我们学习和成长的过程。

##### **阶段 2.1: “Hello, Window!” - 基础设施的搭建与陷阱**

*   **目标**: 验证开发环境，搭建一个能显示窗口的基础框架。
*   **核心内容**:
    *   **`Makefile`**: 我们没有选择IDE的“一键编译”，而是手动编写了`Makefile`。这让我们深刻理解了C语言项目的编译流程：源代码（`.c`）-> 目标文件（`.o`）-> 可执行文件。
    *   **SDL2集成**: 我们引入了SDL2库来处理图形和输入，这是现代模拟器开发的标准实践，它将我们从繁琐的平台相关API中解放出来。
*   **遇到的关键问题**: **`undefined reference to 'WinMain'`**
    *   **问题本质**: 这是Windows平台下**控制台程序**与**GUI程序**入口点冲突的经典问题。SDL2库为了跨平台，默认会“劫持”`main`函数，试图将程序链接为GUI程序，但这与GCC的默认行为（链接为控制台程序）产生了冲突。
    *   **解决方案**: 通过在`main.c`的开头定义宏`#define SDL_MAIN_HANDLED`，我们明确地告诉SDL2：“`main`函数由我来管理，你无需干预”。这个小小的宏，背后是深刻的操作系统与库交互的原理。

##### **阶段 2.2: “CPU的诞生” - 从结构体到第一条指令**

*   **目标**: 创建CPU和总线的核心数据结构，并实现第一条指令`LDA #$XX`。
*   **核心内容**:
    *   **模块化设计**: 我们将`cpu`和`bus`分离到不同的模块（`.h`/`.c`文件），并通过`#include`建立依赖关系。这是软件工程的基石。
    *   **`cpu.h`**: 定义了`CPU`结构体，包含了A, X, Y等所有核心寄存器。这是CPU的“静态蓝图”。
    *   **`bus.c`**: 实现了最简单的内存（2KB RAM）和读写函数。
    *   **`cpu.c`**: 实现了`cpu_step`函数，并用一个`switch`语句来处理`0xA9` (LDA Immediate) 操作码。
*   **遇到的关键问题**:
    1.  **`'Bus' has no member named 'read'`**: 我们错误地使用了`cpu->bus->read()`的语法，试图将全局函数`bus_read`当作`Bus`结构体的成员。
        *   **问题本质**: 混淆了C语言的**结构体成员访问** (`->`) 与**全局函数调用**。
        *   **解决方案**: 改为正确的`bus_read(cpu->bus, address)`语法，将`bus`指针作为参数传递。这让我们理解了模块间通过函数API进行交互的基本模式。
    2.  **CPU状态一成不变**: 我们的CPU无法正确执行加载到`$C000`的指令。
        *   **问题本质**: **地址空间映射错误**。我们的总线只认识RAM所在的`$0000-$1FFF`地址空间，而`$C000`在它看来是一片“无人区”，读取该地址只会返回0。
        *   **解决方案**: 将测试程序和PC的起始地址都移到RAM中的`$0600`。这个调试过程，让我们第一次直观地理解了“内存地址映射”这一核心概念。

##### **阶段 2.3: “数据驱动的进化” - 从`switch`到查找表**

*   **目标**: 重构CPU，用更优雅、可扩展的方式来管理指令集，并添加`TAX`和`INX`。
*   **核心内容**:
    *   **指令查找表 (Instruction Lookup Table)**: 我们定义了一个`Instruction`结构体，包含一个函数指针成员`execute`。然后创建了一个256项的数组`instruction_table`，用操作码作为索引。
    *   **`cpu_step`的重构**: `switch`语句被替换为一行简洁的代码：`instruction_table[opcode].execute(cpu);`。
*   **遇到的关键问题**: **`-Woverride-init` 警告**
    *   **问题本质**: 我们使用了GCC的扩展语法`[0x00 ... 0xFF]`来初始化整个表，然后再覆盖特定条目。这种在同一个初始化块中的“先全覆盖，再单点修改”的行为，被编译器认为是有风险的。
    *   **解决方案**: 改为**运行时初始化**。我们创建了一个`cpu_power_up`函数，用一个循环来填充默认值，然后再逐一设置已实现的指令。这牺牲了一点点静态初始化的简洁性，但换来了**代码的类型安全、可移植性和逻辑清晰性**。

##### **阶段 2.4: “学会读写” - 引入寻址模式**

*   **目标**: 实现`LDA`和`STA`的Zero Page版本，让CPU具备完整的内存读写能力。
*   **核心内容**:
    *   **寻址模式抽象**: 我们在`Instruction`结构体中增加了`AddressingMode`枚举和`get_operand_address`函数指针。`cpu_step`的流程被重构为“取指令 -> 计算地址 -> 执行指令”。
*   **遇到的关键问题**: **指令错位与无限循环**
    *   **问题本质**: **PC（程序计数器）更新逻辑不一致**。我们的`get_operand_address`函数在处理Zero Page模式时，通过调用`cpu_fetch_byte`正确地消耗了操作数，但在处理Immediate模式时，忘记了消耗操作数，导致PC指针停留在了操作数上，引发了后续的指令流混乱。
    *   **解决方案**: 在`get_operand_address`的`AM_IMM`分支中，将`return cpu->pc;`修改为`return cpu->pc++;`。这个小小的`++`，体现了对CPU指令周期中PC指针精确控制的深刻理解。

##### **阶段 2.5: “最终的考验” - 通关`nestest.nes`**

*   **目标**: 加载并运行`nestest.nes`，最终生成与官方日志完全一致的输出。
*   **核心内容**:
    *   **`cartridge`模块**: 实现了`.nes`文件加载，包括对iNES文件头的解析和PRG/CHR ROM的动态内存分配。
    *   **总线扩展**: 将对`$8000-$FFFF`地址的访问路由到卡带的PRG-ROM。
    *   **实现复位向量**: `cpu_reset`不再硬编码PC，而是模拟硬件行为，从`$FFFC-$FFFD`读取地址。
    *   **批量实现指令**: 我们以惊人的速度，将`nestest`所需的几乎所有指令和寻址模式都添加到了CPU中。
*   **遇到的关键问题**: **`-Wcast-function-type` 警告刷屏**
    *   **问题本质**: 为了“简洁”，我们用一个宏将不同函数签名的实现函数，强制转换为统一的类型塞进指令表。这严重破坏了C语言的**类型系统**。
    *   **解决方案**: **回归本源，尊重类型**。我们为每一类指令（如算术、逻辑、转移等）编写了具有统一签名的“包装函数”，由这些包装函数去调用真正的逻辑。虽然代码行数增加了，但**彻底消除了类型风险，使得代码健壮、可维护**。

#### **3. 总结与展望 (Conclusion & What's Next)**

通过这一系列环环相扣的挑战与解决方案，我们不仅仅是“写”出了一个CPU，更是“理解”了一个CPU。我们从最基础的内存读写，到复杂的寻址模式和程序流控制，再到工程上的模块化、数据驱动和类型安全设计，都获得了第一手的、深刻的实践经验。

我们现在拥有一个**经过严格验证、功能完备、代码高质量的6502 CPU核心**。它已经准备好驱动一个完整的虚拟世界。

**下一阶段，我们将为这个强大的“大脑”安装上“眼睛”——PPU**。我们将重拾SDL2，将PPU的像素数据渲染到屏幕上，让我们的模拟器第一次真正“活”起来，显示出丰富多彩的图形。前方的道路依然充满挑战，但有了现在这个坚实的基础，我们无所畏惧。